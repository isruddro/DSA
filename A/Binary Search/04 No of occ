https://www.geeksforgeeks.org/problems/number-of-occurrence2259/1

# Same thing as First and Last occ but extra: max_index - min_index + 1

cpp:
iterative:
Time	O(log n)
Space	O(1)

#include <vector>
using namespace std;

class Solution {
public:
    int countFreq(vector<int>& arr, int target) {
        auto find_bound = [&](bool left_bias) -> int {
            int start = 0, end = arr.size() - 1;
            int bound = -1;

            while (start <= end) {
                int mid = (start + end) / 2;
                if (arr[mid] == target) {
                    bound = mid;
                    if (left_bias)
                        end = mid - 1;  // move left
                    else
                        start = mid + 1;  // move right
                } else if (arr[mid] < target) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }

            return bound;
        };

        int left_index = find_bound(true);
        if (left_index == -1) return 0;

        int right_index = find_bound(false);
        return right_index - left_index + 1;
    }
};

rec:

Time: O(log n)

Space: O(log n) (due to recursion stack)

#include <vector>
#include <limits>
#include <algorithm>
using namespace std;

class Solution {
public:
    int min_index;
    int max_index;

    void binary_search(vector<int>& arr, int start, int end, int target, bool left_bias) {
        if (start > end) return;

        int mid = (start + end) / 2;

        if (arr[mid] > target) {
            binary_search(arr, start, mid - 1, target, left_bias);
        } else if (arr[mid] < target) {
            binary_search(arr, mid + 1, end, target, left_bias);
        } else {
            if (left_bias) {
                min_index = min(min_index, mid);
                binary_search(arr, start, mid - 1, target, left_bias);
            } else {
                max_index = max(max_index, mid);
                binary_search(arr, mid + 1, end, target, left_bias);
            }
        }
    }

    int countFreq(vector<int>& arr, int target) {
        min_index = numeric_limits<int>::max();
        max_index = numeric_limits<int>::min();

        binary_search(arr, 0, arr.size() - 1, target, true);  // left-biased
        binary_search(arr, 0, arr.size() - 1, target, false); // right-biased

        if (min_index == numeric_limits<int>::max())
            return 0;

        return max_index - min_index + 1;
    }
};



py3:
iterative:
Time	O(log n)
Space	O(1)
from typing import List

class Solution:
    def countFreq(self, arr: List[int], target: int) -> int:
        def find_bound(left_bias: bool) -> int:
            start, end = 0, len(arr) - 1
            bound = -1
            while start <= end:
                mid = (start + end) // 2
                if arr[mid] == target:
                    bound = mid
                    if left_bias:
                        end = mid - 1  # keep going left
                    else:
                        start = mid + 1  # keep going right
                elif arr[mid] < target:
                    start = mid + 1
                else:
                    end = mid - 1
            return bound

        left_index = find_bound(True)
        if left_index == -1:
            return 0  # target not found
        right_index = find_bound(False)
        return right_index - left_index + 1


rec:
Time: O(log n)

Space: O(log n) (due to recursion stack)

from typing import List

class Solution:
    def countFreq(self, arr: List[int], target: int) -> int:
        self.min_index = float('inf')
        self.max_index = float('-inf')

        def binary_search(start: int, end: int, left_bias: bool) -> None:
            if start > end:
                return

            mid = (start + end) // 2

            if arr[mid] > target:
                binary_search(start, mid - 1, left_bias)
            elif arr[mid] < target:
                binary_search(mid + 1, end, left_bias)
            else:
                if left_bias:
                    self.min_index = min(self.min_index, mid)
                    binary_search(start, mid - 1, left_bias)
                else:
                    self.max_index = max(self.max_index, mid)
                    binary_search(mid + 1, end, left_bias)

        # run left-biased and right-biased searches
        binary_search(0, len(arr) - 1, True)
        binary_search(0, len(arr) - 1, False)

        if self.min_index == float('inf'):
            return 0  # target not found
        return self.max_index - self.min_index + 1


cpp:
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int minIndex = INT_MAX;
int maxIndex = INT_MIN;

void BinarySearch(int start, int end, const vector<int>& arr, int target, bool leftBias) {
    if (start > end) return;

    int mid = (start + end) / 2;

    if (arr[mid] > target) {
        BinarySearch(start, mid - 1, arr, target, leftBias);
    }
    else if (arr[mid] < target) {
        BinarySearch(mid + 1, end, arr, target, leftBias);
    }
    else {
        if (leftBias) {
            minIndex = min(minIndex, mid);
            BinarySearch(start, mid - 1, arr, target, leftBias);
        } else {
            maxIndex = max(maxIndex, mid);
            BinarySearch(mid + 1, end, arr, target, leftBias);
        }
    }
}

int CountOccurrences(const vector<int>& arr, int x) {
    minIndex = INT_MAX;
    maxIndex = INT_MIN;

    BinarySearch(0, arr.size() - 1, arr, x, true);   // Find leftmost occurrence
    BinarySearch(0, arr.size() - 1, arr, x, false);  // Find rightmost occurrence

    if (minIndex == INT_MAX) minIndex = -1;
    if (maxIndex == INT_MIN) maxIndex = -1;

    if (minIndex == -1) return 0;  // Target not found
    return maxIndex - minIndex + 1; // Count of occurrences
}

int main() {
    vector<int> arr = {2, 4, 4, 4, 6, 8, 8, 10};
    int x = 4;

    int count = CountOccurrences(arr, x);
    cout << "The count of " << x << " is: " << count << endl;

    return 0;
}






c#:


using System;

class Program
{
    static int minIndex = int.MaxValue;
    static int maxIndex = int.MinValue;

    static void BinarySearch(int start, int end, int[] arr, int target, bool leftBias)
    {
        if (start > end) return;

        int mid = (start + end) / 2;

        if (arr[mid] > target)
        {
            BinarySearch(start, mid - 1, arr, target, leftBias);
        }
        else if (arr[mid] < target)
        {
            BinarySearch(mid + 1, end, arr, target, leftBias);
        }
        else
        {
            if (leftBias)
            {
                minIndex = Math.Min(minIndex, mid);
                BinarySearch(start, mid - 1, arr, target, leftBias);
            }
            else
            {
                maxIndex = Math.Max(maxIndex, mid);
                BinarySearch(mid + 1, end, arr, target, leftBias);
            }
        }
    }

    static int CountOccurrences(int[] arr, int n, int x)
    {
        minIndex = int.MaxValue;
        maxIndex = int.MinValue;

        BinarySearch(0, n - 1, arr, x, true);  // Find leftmost occurrence
        BinarySearch(0, n - 1, arr, x, false); // Find rightmost occurrence

        if (minIndex == int.MaxValue) minIndex = -1;
        if (maxIndex == int.MinValue) maxIndex = -1;

        if (minIndex == -1) return 0; // Target not found
        return maxIndex - minIndex + 1; // Count of occurrences
    }

    static void Main()
    {
        int[] arr = { 2, 4, 4, 4, 6, 8, 8, 10 };
        int n = arr.Length;
        int x = 4;

        int count = CountOccurrences(arr, n, x);
        Console.WriteLine($"The count of {x} is: {count}");
    }
}
